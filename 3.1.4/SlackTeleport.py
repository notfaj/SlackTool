import asyncio
from wizwalker import XYZ, Keycode
from wizwalker.file_readers.wad import Wad
import math
import struct
from io import BytesIO
from typing import Tuple, Union
from loguru import logger

type_format_dict = {
"char": "<c",
"signed char": "<b",
"unsigned char": "<B",
"bool": "?",
"short": "<h",
"unsigned short": "<H",
"int": "<i",
"unsigned int": "<I",
"long": "<l",
"unsigned long": "<L",
"long long": "<q",
"unsigned long long": "<Q",
"float": "<f",
"double": "<d",
}
@logger.catch
class TypedBytes(BytesIO):
	def split(self, index: int) -> Tuple["TypedBytes", "TypedBytes"]:
		self.seek(0)
		buffer = self.read(index)
		return type(self)(buffer), type(self)(self.read())
	def read_typed(self, type_name: str):
		type_format = type_format_dict[type_name]
		size = struct.calcsize(type_format)
		data = self.read(size)
		return struct.unpack(type_format, data)[0]

# implemented from https://github.com/PeechezNCreem/navwiz/
# this licence covers the below function
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
@logger.catch
def parse_nav_data(file_data: Union[bytes, TypedBytes]):
	# ty starrfox for remaking this
	if isinstance(file_data, bytes):
		file_data = TypedBytes(file_data)
	vertex_count = file_data.read_typed("short")
	vertex_max = file_data.read_typed("short")
	# unknown bytes
	file_data.read_typed("short")
	vertices = []
	idx = 0
	while idx <= vertex_max - 1:
		x = file_data.read_typed("float")
		y = file_data.read_typed("float")
		z = file_data.read_typed("float")
		vertices.append(XYZ(x, y, z))
		vertex_index = file_data.read_typed("short")
		if vertex_index != idx:
			vertices.pop()
			vertex_max -= 1
		else:
			idx += 1
	edge_count = file_data.read_typed("int")
	edges = []
	for idx in range(edge_count):
		start = file_data.read_typed("short")
		stop = file_data.read_typed("short")
		edges.append((start, stop))
	return vertices, edges

@logger.catch
class SlackTeleport():
	def __init__(self, client):
		self.client = client

	def calc_PointOn3DLine(self, xyz_1 : XYZ, xyz_2 : XYZ, additional_distance):
		# extends a point on the line created by 2 XYZs by additional_distance. xyz_1 is the origin.
		distance = math.sqrt((pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0)))
		n = ((distance - additional_distance) / distance)
		return XYZ(x=((xyz_2.x - xyz_1.x) * n) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * n) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * n) + xyz_1.z)

	def calc_multiplerPointOn3DLine(self, xyz_1 : XYZ, xyz_2 : XYZ, multiplier : float):
		# extends a point on the line created by 2 XYZs by a multiplier. xyz_1 is the origin.
		return XYZ(x=((xyz_2.x - xyz_1.x) * multiplier) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * multiplier) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * multiplier) + xyz_1.z)

	def calc_MidPoint(self, xyz_1 : XYZ, xyz_2 : XYZ, distance_multiplier : float = 0.5):
		# calculates the midpoint of 2 XYZs. 
		distance = math.sqrt((pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0)))
		n = distance_multiplier
		return XYZ(x=((xyz_2.x - xyz_1.x) * n) + xyz_1.x, y=((xyz_2.y - xyz_1.y) * n) + xyz_1.y, z=((xyz_2.z - xyz_1.z) * n) + xyz_1.z)

	def calc_AveragePoint(self, xyz_list : list[XYZ]):
		# calculates the "midpoint" of a list of XYZs. 
		x_list = [x.x for x in xyz_list]
		y_list = [y.y for y in xyz_list]
		z_list = [z.z for z in xyz_list]
		return XYZ(x=(sum(x_list) / len(x_list)), y=(sum(y_list) / len(y_list)), z=(sum(z_list) / len(z_list)))

	def rotate_point(self, origin_xyz : XYZ, point_xyz : XYZ, theta):
		# rotates point_xyz about origin_xyz, by theta degrees counterclockwise. This doesn't take the Z into account, so don't use this for anything that needs the Z to rotate.
		radians = math.radians(theta)
		cos = math.cos(radians)
		sin = math.sin(radians)
		y_diff = point_xyz.y - origin_xyz.y
		x_diff = point_xyz.x - origin_xyz.x
		x = cos * x_diff - sin * y_diff + origin_xyz.x
		y = sin * x_diff + cos * y_diff + origin_xyz.y
		return XYZ(x=x, y=y, z=point_xyz.z)

	def are_xyzs_within_threshold(self, xyz_1 : XYZ, xyz_2 : XYZ, threshold : int = 200):
		# checks if 2 xyz's are within a rough distance threshold of each other. Not actual distance checking, but precision isn't needed for this, this exists to eliminate tiny variations in XYZ when being sent back from a failed port.
		threshold_check = [abs(abs(xyz_1.x) - abs(xyz_2.x)) < threshold, abs(abs(xyz_1.y) - abs(xyz_2.y)) < threshold, abs(abs(xyz_1.z) - abs(xyz_2.z)) < threshold]
		return all(threshold_check)

	def calc_Distance(self, xyz_1 : XYZ, xyz_2 : XYZ):
		# calculates the distance between 2 XYZs
		return math.sqrt((pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0)))

	def calc_squareDistance(self, xyz_1 : XYZ, xyz_2 : XYZ):
		# calculates the distance between 2 XYZs, but doesn't square root the answer to be much more efficient. Useful for comparing distances, not much else.
		return (pow(xyz_1.x - xyz_2.x, 2.0)) + (pow(xyz_1.y - xyz_2.y, 2.0)) + (pow(xyz_1.z - xyz_2.z, 2.0))

	async def calc_up_XYZ(self, xyz : XYZ = None, speed_constant : int = 580, speed_adjusted : bool = True):
		# handles optional xyz param, will default to using the position of the client
		if not xyz:
			client_xyz = await self.client.body.position()
		else:
			client_xyz = xyz

		# handles speed adjustment param
		if speed_adjusted:	
			additional_speed = await self.client.client_object.speed_multiplier()
		else:
			additional_speed = 0

		# adjusts speed constant based on speed multiplier, and adds it to the Z value
		new_z = client_xyz.z + (speed_constant * ((additional_speed / 100) + 1))

		return XYZ(x=client_xyz.x, y=client_xyz.y, z=new_z)

	async def calc_FrontalVector(self, xyz : XYZ = None, yaw : float = None, speed_constant : int = 580, speed_adjusted : bool = True, length_adjusted : bool = True):
		# handle if it is adjusted via speed multiplier or just uses the set constant
		if speed_adjusted:
			current_speed = await self.client.client_object.speed_multiplier()
		else:
			current_speed = 0

		# handles optional xyz param, will default to using the position of the client
		if not xyz:
			xyz = await self.client.body.position()

		# handles optional yaw paraam, will default to using the yaw of the client
		if not yaw:
			yaw = await self.client.body.yaw()
		else:
			yaw = yaw

		# adjust the speed constant based on the speed multiplier
		additional_distance = speed_constant * ((current_speed / 100) + 1)

		# calculate point "in front" of XYZ/client using yaw 
		frontal_x = (xyz.x - (additional_distance * math.sin(yaw)))
		frontal_y = (xyz.y - (additional_distance * math.cos(yaw)))
		frontal_xyz = XYZ(x=frontal_x, y=frontal_y, z=xyz.z)

		# make a length adjustment since diagonal movements 
		if length_adjusted:
			distance = self.calc_Distance(xyz, frontal_xyz)
			final_xyz = self.calc_PointOn3DLine(xyz_1=xyz, xyz_2=frontal_xyz, additional_distance=(additional_distance - distance))
		else:
			final_xyz = frontal_xyz

		return final_xyz

	async def teleport_move_adjust(self, xyz : XYZ, delay : float = 0.8):
		# teleports the client to a given XYZ, and jitters afterward to actually update the position
		await self.client.teleport(xyz)
		await self.client.send_key(Keycode.A, 0.05)
		await self.client.send_key(Keycode.D, 0.05)
		await asyncio.sleep(delay)

	async def is_teleport_valid(self, destination_xyz : XYZ, origin_xyz : XYZ):
		# checks if a client actually teleported to its destination.
		original_zone_name = await self.client.zone_name()
		await self.teleport_move_adjust(destination_xyz)

		# we know the teleport didn't succeed if we are very close to where we were, and the zone name hasn't changed
		if self.are_xyzs_within_threshold(await self.client.body.position(), origin_xyz, 50) and await self.client.zone_name() == original_zone_name:
			return False
		else:
			return True

	async def auto_adjusting_teleport(self):
		# DEPRECATED: Uses brute forcing XYZs in an alternating spiral pattern to find usable coords to port to. VERY slow.
		original_zone_name = await self.client.zone_name()
		original_position = await self.client.body.position()
		quest_position = await self.client.quest_position.position()
		adjusted_position = quest_position
		mod_amount = 50
		current_angle = 0
		await self.teleport_move_adjust(self.client, quest_position)
		while self.are_xyzs_within_threshold((await self.client.body.position()), original_position, 50) and await self.client.zone_name() == original_zone_name:
			adjusted_position = self.calc_PointOn3DLine(original_position, quest_position, mod_amount)
			rotated_position = self.rotate_point(quest_position, adjusted_position, current_angle)
			await self.teleport_move_adjust(self.client, rotated_position)
			mod_amount += 100
			current_angle += 92

	async def load_wad(self, path: str):
		return Wad.from_game_data(path.replace("/", "-"))

	async def navmap_tp(self, xyz=None, minimum_distance_increment=250, walk_after=True):
		original_zone_name = await self.client.zone_name()
		original_position = await self.client.body.position()
		if xyz:
			quest_pos = xyz
		else:
			quest_pos = await self.client.quest_position.position()
		minimum_vertex_distance = minimum_distance_increment
		await self.teleport_move_adjust(quest_pos)
		wad = await self.load_wad(await self.client.zone_name())
		nav_data = await wad.get_file("zone.nav")
		vertices = []
		vertices, _ = parse_nav_data(nav_data)
		squared_distances = [self.calc_squareDistance(quest_pos, n) for n in vertices]
		sorted_distances = sorted(squared_distances)
		while self.are_xyzs_within_threshold(xyz_1=(await self.client.body.position()), xyz_2=original_position, threshold=100) and await self.client.zone_name() == original_zone_name:
			# set minimum distance between 2 chosen vertices
			minimum_vertex_distance += minimum_distance_increment
			for s in sorted_distances:
				current_index = sorted_distances.index(s)
				if current_index + 1 < len(sorted_distances):
					# this is REALLY inefficient but I'll fix it later maybe
					# selection of the 2 closest vertices that satisfy the criteria
					vertex = vertices[int(squared_distances.index(sorted_distances[current_index]))]
					next_vertex = vertices[int(squared_distances.index(sorted_distances[current_index + 1]))]
					between_vertices = self.calc_Distance(vertex, next_vertex)
					quest_to_vertex = self.calc_Distance(quest_pos, next_vertex)
					if between_vertices >= quest_to_vertex or between_vertices < minimum_vertex_distance:
						pass
					elif between_vertices < quest_to_vertex and between_vertices >= minimum_vertex_distance:
						adjusted_pos = self.calc_AveragePoint([vertex, next_vertex, quest_pos, quest_pos])
						await self.teleport_move_adjust(XYZ(x=adjusted_pos.x, y=adjusted_pos.y, z=max([quest_pos.z, adjusted_pos.z])))
						break
					else:
						pass
				else:
					break
		# walks to desired XYZ, only if the zone hasn't changed and if the param is enabled.
		if walk_after:
			if await self.client.zone_name() == original_zone_name:
				# splits up a walk to quest into 5 segments, checking for zone changes each time. This fixes a bug where the walk to quest outlasts the loading screen, producing very strange behaviour.
				points_on_line = [self.calc_multiplerPointOn3DLine(xyz_1=(await self.client.body.position()), xyz_2=quest_pos, multiplier=((i + 1) / 5)) for i in range(3)]
				for p in points_on_line:
					if await self.client.zone_name() == original_zone_name:
						try:
							await self.client.goto(p.x, p.y)
						except:
							await asyncio.sleep(0.1)
					else:
						break
				if await self.client.zone_name() == original_zone_name:
					try:
						await self.client.goto(quest_pos.x, quest_pos.y)
					except:
						await asyncio.sleep(0.1)

	# async def did_teleport_succeed(self, xyz: XYZ, zone_name: str, threshold: int = 100):
	# 	current_xyz = await self.client.body.position()
	# 	current_zone_name = await self.client.zone_name()
	# 	if self.are_xyzs_within_threshold(current_xyz, xyz, threshold) and current_zone_name == zone_name:
	# 		return False
	# 	else:
	# 		return True

	# async def navmap_tp(self, xyz: XYZ, minimum_distance_increment : int = 200, threshold: int = 200, skip_initial_tp: bool = False):
	# 	# Uses the current zone's navmap to 
	# 	zone_name = await self.client.zone_name()
	# 	if not xyz:
	# 		xyz = await self.client.quest_position.position()

	# 	current_xyz = await self.client.body.position()
	# 	if not skip_initial_tp:
	# 		await self.teleport_move_adjust(xyz)
	# 	if not await self.did_teleport_succeed(current_xyz, zone_name, threshold):
	# 		logger.info('Detection of failed TP is working')
	# 		wad = await self.load_wad(await self.client.zone_name())
	# 		nav_data = await wad.get_file("zone.nav")
	# 		vertices = []
	# 		vertices, _ = parse_nav_data(nav_data)
	# 		logger.info('getting navmap is working')

	# 		vertex_distances = {}
	# 		for v in vertices:
	# 			vertex_distances[v] = self.calc_squareDistance(v, xyz)
	# 		logger.info('square distance shit is working')

	# 		inverted_vertex_distances = {v: k for k, v in vertex_distances.items()}

	# 		square_distances = list(inverted_vertex_distances.keys())
	# 		sorted_vertex_distances = square_distances.sort(reverse=True)
	# 		sorted_vertices = [inverted_vertex_distances[i] for i in sorted_vertex_distances]
	# 		logger.info('dict and sorted list creation is working')

	# 		# while not await self.did_teleport_succeed(xyz, zone_name, threshold):
	# 		length = len(sorted_vertices)
	# 		vertex_1 = None
	# 		vertex_2 = None
	# 		for v_index, v in enumerate(sorted_vertices):
	# 			modifier = 0
	# 			next_index = 0
	# 			# account for if this is the last vertex in the list, or somehow the count goes higher than that
	# 			if (v_index + 1) >= length:
	# 				modifier = (length - v_index) + 1

	# 			next_index = (v_index + 1) - modifier
	# 			next_vertex = sorted_vertices[next_index]
	# 			if self.calc_squareDistance(xyz, v) <= self.calc_squareDistance(v, next_vertex):
	# 				continue
	# 			elif self.calc_Distance(v, next_vertex) < minimum_distance_increment:
	# 				continue
	# 			else:
	# 				vertex_1 = v
	# 				vertex_2 = next_vertex
	# 				adjusted_pos = self.calc_AveragePoint([vertex_1, vertex_2, xyz, xyz])
	# 				current_xyz = await self.client.body.position()
	# 				await self.teleport_move_adjust(XYZ(x=adjusted_pos.x, y=adjusted_pos.y, z=xyz.z))
	# 				if not await self.did_teleport_succeed(current_xyz, zone_name, threshold):
	# 					continue
	# 				else:
	# 					break
	# 		else:
	# 			await self.navmap_tp(minimum_distance_increment = (minimum_distance_increment + 250), skip_initial_tp=True)

	# 		# TODO: Walking to quest using pathfinding

	# async def test_teleports(self, xyz_list : list[XYZ]):



	def calc_angle(self, p1 : XYZ, p2 : XYZ, p3 : XYZ = None):
		if not p3:
			p3 = XYZ(x=p1.x, y=p2.y, z=p1.z)
		return math.degrees(math.atan2(p3.y - p1.y, p3.x - p1.x) - math.atan2(p2.y - p1.y, p2.x - p1.x))

	# async def get_navmap_endpoints(self):
	# 	# gets the endpoints of the navmap using the jarvis march algorithm

	# 	# get the navmap points of the current zone
	# 	wad = await self.load_wad(await self.client.zone_name())
	# 	nav_data = await wad.get_file("zone.nav")
	# 	vertices = []
	# 	vertices, _ = parse_nav_data(nav_data)

	# 	# create a dictionary for each point's x and y values, z values are irrelevant
	# 	x_values = {}
	# 	y_values = {}
	# 	for v in vertices:
	# 		x_values[v] = v.x
	# 		y_values[v] = v.y

	# 	# find the point with the lowest y value
	# 	lowest_y_coord = min(y_values, key= lambda x: y_values[x])

	# 	# create initial point for hull
	# 	hull = [lowest_y_coord]
	# 	# repeats until the hull as formed a closed polygon, or if something goes wrong it also stops when the number of hull points has exceeded the number of vertices.
	# 	while True and len(hull) <= len(vertices):
	# 		# only adds points to the hull if the counterclockwise angle is smallest relative to the previous hull point, among the unused vertices.
	# 		for v in vertices:
	# 			angles = {}
	# 			angles[v] = self.calc_angle(p1=v, p2=hull[-1])
	# 			hull.append(min(angles, key= lambda x: angles[x]))
	# 		# if the last item in the hull is the lowest y coord we know we fully looped around, and can simply return the hull
	# 		if hull[-1] != lowest_y_coord:
	# 			vertices.remove(hull[-1])
	# 		else:
	# 			break

	# 	return hull

	# def find_closest_point(self, xyz, xyz_list):
	# 	distances = {}
	# 	for e in xyz_list:
	# 		distances[e] = self.calc_squareDistance(xyz, e)
	# 	return min(distances, key= lambda x: distances[x])
		
	# async def navmap_walk_to(self, vertices, edges, xyz):
	# 	# assign quest XYZ/vertices/edges in case a custom one isn't defined
	# 	if not vertices or not edges:
	# 		zone_name = await self.client.zone_name()
	# 		wad = await self.load_wad(zone_name)
	# 		nav_data = await wad.get_file("zone.nav")
	# 		vertices, edges = parse_nav_data(nav_data)
	# 	if not xyz:
	# 		xyz = await self.client.quest_position.position()

	# 	original_position = await self.client.body.position()
	# 	# this is an attempted implementation of Dijkstra’s algorithm, but using a faster distance function

	# 	# find the closest vertices to our current and desired XYZ
	# 	original_position_vertex = await self.find_closest_point(original_position, vertices)
	# 	xyz_vertex = await self.find_closest_point(xyz, vertices)

	# 	vertex_index = {}
	# 	for v in vertices:
	# 		index = vertices.index(v)
	# 		vertex_index[v] = index
		
	# 	# elmiminate all "reverse edges" from the graph
	# 	edges = edges[::2]
	# 	current_index = vertex_index[original_position_vertex]
	# 	while True:
	# 		# find only the connecting vertices to the current index
	# 		relevant_indices = []
	# 		for e in edges:
	# 			(i1, i2) = e
	# 			if i1 == current_index:
	# 				relevant_indices.append(i2)
			
	# 		# relevant_vertices = [vertices[int(r)] for r in relevant_indices]
	# 		# closest_vertex = await self.find_closest_point()

	# def calc_nodeSquareDistance(self, index_1, index_2, edges, vertices):
	# 	v1 = vertices[index_1]
	# 	v2 = vertices[index_2]
	# 	return self.calc_squareDistance(v1, v2)

	# async def BFS(self, vertices, edges, src, dest):
	# 	# attempt at implementing BFS algorithm to find a path from 2 xyzs

	# 	# find closest vertices in graph to destination and src
	# 	src_vertex = self.find_closest_point(src, vertices)
	# 	dest_vertex = self.find_closest_point(dest, vertices)


	# 	queue = deque([])


				
				


			











